package de.orat.math.cga.api;

import org.jogamp.vecmath.Matrix3d;
import org.jogamp.vecmath.Matrix4d;
import org.jogamp.vecmath.Quat4d;
import org.jogamp.vecmath.Vector3d;

/**
 * Spin- or pure rotation (oround an axis passing the origin).
 * 
 * 1.0,                         // grade 0<br>
 * e1^e2,    e2^e3,    e3^e1    // grade 2<p>
 * 
 * Euclidean Spin Rotors are generated by a spacelike Bivector B = e 12 + e 13 + e 23 with
 * B 2 < 0 and weighted bases (i.e. αe 1 , βe 2 , γe 3 ). The exponential expression R = e B
 * with B = I 2 θ admits a familiar expansion: e B = cos θ/2 − sin θ/2 I.<p>
 * 
 * @author Oliver Rettig (Oliver.Rettig@orat.de)
 */
public class CGASpinor extends CGARotor {
    
    public CGASpinor(CGAMultivector m){
        super(m.impl);
        // test grade 4 verbieten
        //TODO
    }
    
    
    /**
     * Constructs a rotor with rotation axis passing the origin.
     * 
     * @param B normalized bivector representing the rotation axis 
     * @param theta in radians
     */
    public CGASpinor(CGAEuclideanBivector B, double theta){
        this(B.gp(-theta/2d).exp());
    }
    /**
     * Creates a rotor for rotating around an axis passing the origin, sometimes
     * called pure rotation.
     * 
     * @param a together b representing a rotation plane passing the origin
     * @param b together a representing a rotation plane passing the origin
     * @param theta 
     */
    public CGASpinor(Vector3d a, Vector3d b, double theta){
       this(createBivector(a,b), theta);
    }
    private static CGAEuclideanBivector createBivector(Vector3d a,Vector3d b){
        CGAEuclideanBivector B = new CGAEuclideanBivector(a,b);
        B.normalize();
        return B;
    }
    
    
    // decomposition
    
    /**
     * Decompose pure rotation (around origin).
     *
     * [Hildenbrand2013] book 9.1.1
     * 
     * @return quaternion representing a rotation around the origin
     * 
     * ungetestet
     */
    public Quat4d decompose(){
        Quat4d result = new Quat4d();
        result.w = impl.scalarPart();
        //  * s, eo, e1, eo^e1, e2, eo^e2, e1^e2, eo^e1^e2, e3, eo^e3, e1^e3, eo^e1^e3,
        //  e2^e3, eo^e2^e3, e1^e2^e3, eo^e1^e2^e3, ei, eo^ei, e1^ei, eo^e1^ei,
        //  e2^ei, eo^e2^ei, e1^e2^ei, eo^e1^e2^ei, e3^ei, eo^e3^ei, e1^e3^ei, 
        //  eo^e1^e3^ei, e2^e3^ei, eo^e2^e3^ei, e1^e2^e3^ei, eo^e1^e2^e3^ei
        double[] vector = extractCoordinates();
        result.x = -vector[12]; // i
        result.y = vector[10];  // j
        result.z = -vector[6]; // k
        return result;
    }
    // ungetestet
    public Matrix3d decompose2Matrix(){
        // s, eo, e1, eo^e1, e2, eo^e2, e1^e2, eo^e1^e2, e3, eo^e3, e1^e3, eo^e1^e3,
        // e2^e3, eo^e2^e3, e1^e2^e3, eo^e1^e2^e3, ei, eo^ei, e1^ei, eo^e1^ei,
        // e2^ei, eo^e2^ei, e1^e2^ei, eo^e1^e2^ei, e3^ei, eo^e3^ei, e1^e3^ei, 
        // eo^e1^e3^ei, e2^e3^ei, eo^e2^e3^ei, e1^e2^e3^ei, eo^e1^e2^e3^ei
        double[] coords = extractCoordinates();
        
        double R0 = coords[0]; // s
        double R1 = coords[3]; // e01
        double R2 = coords[5]; // e02
        double R3 = coords[9]; // e03
        double R4 = coords[6]; // e12
        double R5 = -coords[10]; //e31
        double R6 = coords[12]; // e23
        
        //TODO
        // für mehr Effizient: Produkte vorher bilden und identy als static final vorher erzeugen
        Matrix3d result = new Matrix3d(-R4*R4-R5*R5/*m00*/, R0*R4+R5*R6/*m01*/, R4*R6-R0*R5/*m02*/, 
		    R5*R6-R0*R4/*m10*/, -R4*R4-R6*R6/*m11*/, R0*R6+R4*R5/*m12*/, 
		    R0*R5+R4*R6/*m20*/, R4*R5-R0*R6/*m21*/, -R5*R5-R6*R6/*m22*/);
        result.mul(2d, result);
        Matrix3d identity = new Matrix3d();
        identity.setIdentity();
        result.add(identity);
        return result;
    }
    
    /*public static Quat4d createRotor(CGAMultivector o1, CGAMultivector o2){
        Quat4d result = new Quat4d();
        double cosphi = Math.sqrt((1+(o1.ip(o2))/(o1.norm()*o2.norm()))/2d);
        double sinphi = Math.sqrt((1-(o1.ip(o2))/(o1.norm()*o2.norm()))/2d);
        result.w =
    }*/
}
