package de.orat.math.cga.api;

import org.jogamp.vecmath.Quat4d;
import org.jogamp.vecmath.Vector3d;

/**
 * Spin- or pure rotation (oround an axis passing the origin).
 * 
 * 1.0,                         // grade 0<br>
 * e1^e2,    e2^e3,    e3^e1    // grade 2<p>
 * 
 * Euclidean Spin Rotors are generated by a spacelike Bivector B = e 12 + e 13 + e 23 with
 * B 2 < 0 and weighted bases (i.e. αe 1 , βe 2 , γe 3 ). The exponential expression R = e B
 * with B = I 2 θ admits a familiar expansion: e B = cos θ/2 − sin θ/2 I.<p>
 * 
 * @author Oliver Rettig (Oliver.Rettig@orat.de)
 */
public class CGASpinor extends CGARotor {
    
    public CGASpinor(CGAMultivector m){
        super(m.impl);
        // test grade 4 verbieten
        //TODO
    }
    
    
    /**
     * Constructs a rotor with rotation axis passing the origin.
     * 
     * @param B normalized bivector representing the rotation axis 
     * @param theta in radians
     */
    public CGASpinor(CGAEuclideanBivector B, double theta){
        this(B.gp(-theta/2d).exp());
    }
    /**
     * Creates a rotor for rotating around an axis passing the origin, sometimes
     * called pure rotation.
     * 
     * @param a together b representing a rotation plane passing the origin
     * @param b together a representing a rotation plane passing the origin
     * @param theta 
     */
    public CGASpinor(Vector3d a, Vector3d b, double theta){
       this(createBivector(a,b), theta);
    }
    private static CGAEuclideanBivector createBivector(Vector3d a,Vector3d b){
        CGAEuclideanBivector B = new CGAEuclideanBivector(a,b);
        B.normalize();
        return B;
    }
    
    
    // decomposition
    
    /**
     * Decompose pure rotation (around origin).
     *
     * [Hildenbrand2013] book 9.1.1
     * 
     * @return quaternion representing a rotation around the origin
     * 
     * ungetestet
     */
    public Quat4d decompose(){
        Quat4d result = new Quat4d();
        result.w = impl.scalarPart();
        //  * s, eo, e1, eo^e1, e2, eo^e2, e1^e2, eo^e1^e2, e3, eo^e3, e1^e3, eo^e1^e3,
        //  e2^e3, eo^e2^e3, e1^e2^e3, eo^e1^e2^e3, ei, eo^ei, e1^ei, eo^e1^ei,
        //  e2^ei, eo^e2^ei, e1^e2^ei, eo^e1^e2^ei, e3^ei, eo^e3^ei, e1^e3^ei, 
        //  eo^e1^e3^ei, e2^e3^ei, eo^e2^e3^ei, e1^e2^e3^ei, eo^e1^e2^e3^ei
        double[] vector = extractCoordinates();
        result.x = -vector[12]; // i
        result.y = vector[10];  // j
        result.z = -vector[6]; // k
        return result;
    }
    
    /*public static Quat4d createRotor(CGAMultivector o1, CGAMultivector o2){
        Quat4d result = new Quat4d();
        double cosphi = Math.sqrt((1+(o1.ip(o2))/(o1.norm()*o2.norm()))/2d);
        double sinphi = Math.sqrt((1-(o1.ip(o2))/(o1.norm()*o2.norm()))/2d);
        result.w =
    }*/
}
